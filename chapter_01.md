## 1 章

### オブジェクト指向デザイン

世界は手続き的です。時間は未来に向かって流れ、出来事がひとつまたひとつと生起しては消えていきます。
みなさんの朝の手続きは、起床して、歯を磨き、コーヒーを淹れて、服を着て、仕事に取り掛かるといったところでしょうか。
これら行為は手続き型のソフトウェアでモデリングすることができます。みなさんはそれぞれの行為の順番を知っていて、
その行為が何をするのかコードに書くことができますし、自分の意図でひとつひとつの行為を並べることもできるからです。

世界はオブジェクト指向的でもあります。みなさんが関わるオブジェクトは、配偶者（"spouse"）や猫（"cat"）、
古い自動車やガレージの中のバイクのパーツの山だったり、あるいはドキドキする心臓や健康のためのエクササイズ
のプランかもしれません。これらオブジェクトにはそれぞれ固有の振る舞いがあります。オブジェクトどうしのやり取り
があらかじめ決まっている場合もありますが、あなたの配偶者が思いがけず猫を踏んでしまったことが、
みんなの心臓をドキドキさせたり、あなたにエクササイズのプランを再評価させるような事態だって起こりえます。

オブジェクトの世界では、新たな振る舞いの組み合わせは自然に現れます。`spouse_steps_on_cat` という
手続きを明示的にコーディングする必要はありません。みなさんがすべきことは、歩く配偶者オブジェクトと
踏まれるのが嫌いな猫オブジェクトを作ることだけです。そして、このふたつのオブジェクトをひとつの部屋に
押し込むと思いがけない振る舞いの組み合わせが出現するのです。

この本は、オブジェクト指向なソフトウェアのデザインについて書かれています。
そして、世界はオブジェクトどうしの自発的なやり取りの連続からできているという視点で書かれています。
オブジェクト指向なデザイン（OOD: Object-oriented design）は、みなさんの世界についての認識をシフトさせます。
あらかじめ定義された手続きの集まりとしての世界から、オブジェクト間でやり取りされるメッセージの連続として
の世界へのシフトです。OOD で失敗するのはコーディング技術が不足しているからだと思われそうですが、
実際は世界についての認識が間違っているから失敗するのです。オブジェクト指向なデザインを学ぶには、
まずオブジェクトの世界にどっぷり浸る必要があります。オブジェクト指向な世界観を一度体得してしまえば、
あとはおのずとついてきます。

この本では、浸礼のプロセスを通じてみなさんをオブジェクト指向なデザインへと案内していきます。
本章は、OODについての全般的な議論から出発します。まずデザイン一般について議論したのち、
いつデザインすべきか、それをどう判断すべきかについてお話しします。
そして最後に、オブジェクト指向プログラミングについて概観し、本書で使われる用語を定義します。

#### デザインのススメ

あるソフトウェアが作られるのには何らかの理由があります。トリビアルなゲームであろうと放射線治療の
プログラムであろうと、ターゲットのアプリケーションにすべてが凝縮されています。動くソフトウェア
を生み出すのにもっとも費用対効果の高い方法が苦痛に満ちたプログラミングならば、プログラマはただ黙って
耐え忍ぶか別の仕事を探すことになるでしょう。

幸いにも、みなさんは喜びと生産性、いずれかの二者択一に迫られることはありません。コードを書くことが喜びと
なるようなプログラミングテクニックと費用対効果の高いソフトウェア開発を実現するテクニックとは
オーバーラップします。オブジェクト指向デザインのテクニックは、仕事への意欲とプログラミングにまつわる技術上の
ディレンマを解決します。このテクニックは、書くことが楽しくなるコードによって費用対効果の高いソフトウェアを
生み出します。


##### デザインが解決する問題

あたらしいアプリケーションを書くとしましょう。そのアプリケーションはすべての要件を完全に、
そして正確に実装しているとします。そしてもうひとつこう仮定します。一度書かれたアプリケーション
は決して変更されることはない、と。

このような状況ではデザインは問題になりません。サーカスのパフォーマが摩擦も重力もない世界で
皿回しをするように、プログラムしたアプリケーションが動き出すとあなたはそこから離れ、それが永遠に
動き続ける様子を眺めるのです。どんなに不安定に見えても、コードの皿は回り続け、
ふらふら旋回しながらも決して落ちることはありません。

そう、何も変わらない限りは。

残念ながら何かが変化します。いつもそうです。カスタマは最初から本当に自分が欲しいものが何か分かりませんし、
本当に伝えたいことは言えないものです。みなさんはカスタマのニーズを理解しておらず、どうすればより良くなるのかを
その都度学んでいます。どこから見てもパーフェクトなアプリケーションであっても安泰ということはありません。
アプリケーションが大成功すると、みんなそれにもっと期待するようになります。そうなると変更はさけられません。
これはいたるところで言えることであり、普遍的で不可避なことなのです。

変化する要件は摩擦と重力に相当します。摩擦と重力は慎重に錬成された計画に突如、予期せぬプレッシャ
をかけます。デザインが重要なのは変更の必要性からです。

変更が容易なアプリケーションは書くのが楽しいですし、大きくすることが喜びとなります。柔軟で適応性が高いからです。
変更に抵抗するアプリケーションはまったく逆です。どんな変更も高くつき、変更すればつぎのコストを生みます。
変更しにくいアプリケーションはほとんどの場合、仕事していても楽しくありません。そのうちでも最悪なものは
だんだん恐怖映画じみてきて、不運なプログラマであるみなさんは焼き物の皿が床に砕け落ちる音を聞かれまいとして、
回転する皿の間を血眼になって駆け回るのです。

##### なぜ変更は難しいのか

アプリケーション全体としての振る舞いは、アプリケーションを構成する個々の部品間のやり取りから生まれます。
これらの部品が「オブジェクト」です。そして、オブジェクト間のやり取りは「メッセージ」として具現化します。
正しいメッセージを正しいオブジェクトに送り届けるには、送信者は受信者（レシーバ）についてあらかじめ知って
いなければなりません。しかしこの知識は、送信者と受信者との間に依存関係をもたらし依存関係は変更への足枷
になります。

オブジェクト指向デザインの関心は依存関係の管理にあります。オブジェクト指向デザインは依存関係を調整し
オブジェクトの変更を許容するコーディングテクニックを集めたものです。デザインが不在で、オブジェクト同士
が互いに知りすぎているような依存関係の放置された状況はアプリケーションに非常に大きなダメージを与えてしまいます。
あるひとつのオブジェクトを変更するとその協力者である他のオブジェクトまで変更しなくてはならなくなり、
さらにその仲間へとどんどん広がっていきます。些細な変更を震源としてダメージが放射状にオブジェクトへと
波及していき、終わって見れば変更しなかったコードはなかったというような結末になります。

知りすぎたオブジェクトたちは、自分たちの存在する世界について過剰な期待を抱くようになります。
彼らは口やかましくなり「あるべき」（"just so"）モノを要求し始めます。こうした期待は、期待する彼ら自身を
制約してしまいます。さまざまなコンテキストで再利用されることを、オブジェクトたちは拒みます。
こうしたオブジェクトはテストが難しく、同じように具合の悪いオブジェクトのコピー元になりがちなのです。

小さなアプリケーションであれば、まずいデザインも生き残ることができます。すべてのオブジェクトが互いに密接に
絡み合っていても、みなさんが頭のなかでその様子をパッとイメージできるのなら、まだそのアプリケーションを
アップデートしていくことは可能でしょう。「小さな」アプリケーションのまずいデザインが問題になるのは、
そのアプリケーションが成功して「大きな」アプリケーションのまずいデザインになった時です。そうしたアプリケーション
はタールピット（タールの池）になって、痕跡も残さず溺れ死んでしまいそうなので、そこに足をふみれるのを恐れます。
シンプルであるはずの変更が、アプリケーションのあちこちに連鎖して、コードを破壊しまくり広範囲に書き直さなくては
ならない破目に陥ります。テストは十字砲火の真っただ中にさらされ、救いであるどころか妨害であるかのように扱われ始めます。

##### 実践的デザインとは

アプリケーションはコードの寄せ集めです。デザインとはコードをアレンジすることです。デザインについての考え方が
共通している面識のない二人のプログラマが、同一の問題を異なるコードアレンジで解決することはありえます。
デザインは、同じような訓練を受けた労働者（ワーカー）が規格品を作るためのコードの寄せ集めではありません。
デザインは、考え方の近いアーティストたちがカスタムなアプリケーションを生み出すためのスタジオ（アトリエ）です。
だからデザインはアートです。コードをアレンジするアートなのです。

デザインの難しさのひとつは、あらゆる問題が抱える二つの側面に起因します。今日デリバリするフィーチャだけのために
コードを書いてはいけません。フィーチャだけのためではなくコードを将来変更されるものとして書かなくてはなりません。
ベータ版を拡張していくと、いつしか変更のコストが初期開発コストを上回ってしまいます。デザインの原則はお互いに
オーバーラップしており、あらゆる問題は時間とともに変化していく宿命にあるので、いざデザインしようすると考えられる
ソリューションの数の多さに目が眩むことでしょう。みなさんの仕事は「総合」のひとつです。アプリケーションの要件を
すべて理解したうえで妥当なコストと採用すべきデザインを組み合わせます。そして現時点で費用効率が高く将来も高いで
あろうコードをどうアレンジしたらよいのか頭を絞ります。

未来を考慮に入れることは、通常、プログラミングの領域外にあると考えられている霊能力を頼りにすることと思われる
かもしれません。もちろんそんなことはありません。デザインが考慮する未来は、未知の要件を予測することでもなければ、
未知の要件のうちからひとつ選んでいま実装することでもありません。プログラマは霊能者ではありません。
未来の特定の要件を予測しようとするデザインは、大抵失敗します。実践的なデザインはみなさんのアプリケーションに
これから起こることを予測したりはしません。何かが起こるということ、そしてそれは現時点では何かわからない
ということを受け入れるだけです。未来を推測しない、つまり未来に適合するためのオプションを留保してくれます。
選択しない、つまり動く余地を残してくれます。

デザインの目的は「あとから」もデザインできるようにしておくことであり、デザインすることの第１のゴールは、
変更のコストを下げることにあります。

#### デザイン・ツール

デザインとは決まりきったルール集を遵守することではありません。それは枝分かれする路を辿る旅であり、
さっきの選択がいくつかの可能性を閉じて別の可能性を開いていくプロセスです。デザインするということは、
分岐点がディシジョンポイントになっている要件の迷宮をさまよい歩くことなのです。

彫刻家ののみとヤスリのように、オブジェクト指向デザイナーにもツールがあります。それが原則とパターンです。


##### デザインの原則

SOLID は Michael Feathers が考案し、Robert Martin が普及させた言葉で、オブジェクト指向デザインの
最もよく知られた五つの原則の頭文字に由来します。

* Single Responsibility（単一責務原則）
* Open-Closed（開放／閉鎖原則）
* Liskov Substitution（リスコフの置換原則）
* Interface Segregation（インターフェイス分掌原則）
* Dependency Inversion（依存転地原則）

これ以外にも、Andy Hunt と Dave Thomas が提唱する DRY（Don't Repeat Yourself）やノースイースタン大学の
デメテルプロジェクトの成果である、デメテルの法則（LoD: Law of Demeter）が知られています。

原則それ自体は本書を通じて触れていくことにして、さしあったての疑問はこうです：「これらの原則は地球上のどこからやってきたのか？」。
これら原則は実験的に証明可能な価値があるのでしょうか？それとも単なるだれかの一意見に過ぎないので耳を貸すも貸さないも
みなさんの自由なのでしょうか？そもそも誰がこれらの原則を唱えているのでしょうか？

これらの原則はすべて、コードを書く主体が下した選択に起源を発します。オブジェクト指向なプログラマは早い時期に、
自分たちを楽にするコードアレンジと苦しめるそれがあることに気が付きました。この経験から彼らは、どうすれば良いコードが書けるのか
自分たちの考えを発展させていきました。

そのうちアカデミックな人たちが参戦してきて、論文を書く必要性もあり、これを「グッドネス」と形容することにしました。
それは賞賛に値する目論見です。ものごとを勘定する、つまりコードの「メトリクス」を計測してそのメトリクスと
アプリケーションの品質の良し悪しとの相関を分析することができるのなら（そのためには客観的な指標が必要です）、
コスト減に寄与することはより多く、コスト増をもたらすことはより少なくすることが可能になります。
品質を測定できるという事実はオブジェクト指向デザインを終わりのない議論から計量可能な科学へと変化させました。

1990 年代に Chidamber と Kemerer と Basilis が行ったのはまさにこれでした。かれらはオブジェクト指向なアプリケーションを取り上げ、
コードの品質分析を試みました。かれらは命名と計測を行いました。クラス全体の大きさ、クラス間の膠着度、継承階層の深さと広がり、
メッセージを送信した結果呼び出されたメソッド数などです。重要と思われるコードアレンジをピックアップしてそれらの呼び方を
考案し、コードのメトリクスとそれらコードから構成されるアプリケーションの品質との相関を分析しました。そしてかれらの研究結果は、
ある特定のコードアレンジのテクニックと高品質なコードとには相関関係があることを示しました。

かれらの研究結果がデザインの原則の有効性を証明したとしても、経験豊かなプログラマにとっては眉唾なものと受け止められるでしょう。
かれらの先駆的な研究は、大学院生たちの書いた非常に小さなアプリケーションを対象としていました。この点だけをとっても研究結果を
鵜呑みにするのは控えるべきでしょう。研究対象のアプリケーションコードは、おそらく現実世界のオブジェクト指向アプリケーションを
代表するのものではないでしょう。

しかしながらこの留保は不要です。2001 年 Laing と Coleman は NASA ゴダード宇宙飛行センターで利用されている
アプリケーション（ロケット科学）を調査しました。その目的は明確で「ソフトウェアのクオリティの良し悪しを決めるコードの書き方」
を発見することでした。二人はクオリティの異なる３つのアプリケーションを調査対象にしました。そのうちの１つはクラスが 1617 個あり、
50 万行を超えるコードで記述されていました。二人の調査結果は、先の Chidamber らの結論を裏付けるもので、さらにはデザイン原則の
重要性を確証するものでした。みなさんがこれらの研究をご存知ないとしてもその共通の結論は信じてください。良いデザインの原則は
計測可能であり、原則に従うことでみなさんのコードは改善されるでしょう。

##### デザインパターン

「原則」に加え、オブジェクト指向デザインには「パターン」が含まれます。通称 Gang of Four（GoF）で知られる、Erich Gamma、
Richard Helm、Ralph Johnson、Jon Vlissides の４人は、1995 年にパターンについての先駆的な仕事を行いました。
その『デザインパターン』という本は、パターンを「オブジェクト指向ソフトウェアのデザインにおける問題解決のためのシンプルで
エレガントなソリュション集」として描出し、パターンによってデザインは、より柔軟で、モジュール化されており、再利用可能で、
しかも理解しやすいものになると主張しました。

デザインパターンという考えは非常にパワフルです。共通の問題に名前を付け、共通の方法で問題を解決するという発想は、
曖昧な対象に輪郭を与えてくれました。『デザインパターン』は、あらゆる世代のプログラマたちにコミュニケーションと
コラボレーションの本当の意味を教えてくれました。

パターンは、すべてのデザインする人のツールボックスにその居場所があります。よく知られたパターンは問題を解決するオープンソース
のプログラムといってよいものです。しかしパターンの普及は、駆け出しのプログラマによるパターンの乱用をもたらし、
本人は良いと信じ込んでいるのですが、パターンとしては正しいのですがそれを間違った問題解決に適用してしまいます。
パターンの誤用は複雑で混乱したコードを生みます。それはパターンが悪いのではありません。ツールを利用することでツール自身は間違いません。
ユーザがツールの使い方をマスターしなければならないのです。

本書はパターンについて書かれたものではありません。とはいえ、みなさんがパターンを理解する手助けをし、
パターンを正しく利用するための知識を提供します。





> under development


#### まとめ

充分長い時間動いているアプリケーション、つまり成功しているアプリケーションが遭遇する最大の
問題は変更への対処です。変更に対して手際よく対処できるようコードをアレンジすることはデザインの仕事です。
デザインでいちばんわかりやすい要素は基本原則とパターンですが、基本原則をいくら正しく適用しても、
パターンをいくら適切に使っても変更しやすいアプリケーションの開発を保証してくれたりはしません。

メトリクスは、アプリケーションがどの程度オブジェクト指向デザインの基本原則をフォローしているのか
教えてくれます。メトリクスの悪いアプリケーションは将来何らかの問題に出くわすでしょう。
しかし、メトリクスが良いからといって楽観はできません。問題を起こすようなデザインのメトリクスが良い
場合もあるでしょうし、メトリクスが良くても変更のコストは高いままかもしれません。

良いデザインの秘訣は、デザインの理論をきちんと習得すること、そして習得した理論を適切に、
つまり正しいタイミングで正しい量を適用することです。デザインの良し悪しは理論を実践に翻訳する
みなさんの力量にかかっています。

理論と実践の違いは何でしょう？

理論には何もありません。もし理論が実践ならば、オブジェクト指向デザインのルールを習得し、ひたすらルールを
適用していけば、その日からパーフェクトなコードを書くことができるでしょう。そこでみなさんの仕事は完了です。

理論がいくらそれを正しいと主張したところで、その主張をよりよく知っているのは実践のほうです。
理論とはちがい、実践は自らの手を汚します。煉瓦を積み上げ、橋を架け、コードを書くのは実践です。
実践は、変化と混乱と不確実に満ちた現実の世界に生きています。いくつもの選択肢を秤にかけ、苦々しくありながらも、
ときにより邪悪でないほうを選択しなければならないような状況に遭遇します。身をかわし、隠れ、借りた金で返済したり
するのが実践です。いまある資源でベストを尽くし身過ぎ世過ぎすることが実践です。

理論は有益であり必要というのが本章の主張でした。ですがもう理論は十分です。実践に移りましょう。


