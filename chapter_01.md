## 1 章

### オブジェクト指向デザイン

世界は手続き的です。時間は未来に向かって流れ、出来事がひとつまたひとつと生起しては消えていきます。
みなさんの朝の手続きは、起床して、歯を磨き、コーヒーを淹れて、服を着て、仕事に取り掛かるといった感じでしょうか。
このような行為は手続き型のソフトウェアでモデリングすることができます。みなさんはそれぞれの行為の順番を知っていて、
行為が何をするのかコードで書くことができますし、自分の意図でひとつひとつの行為を並べることができるからです。

世界はオブジェクト指向的でもあります。みなさんが関わるオブジェクトは、配偶者（"spouse"）や猫（"cat"）、
古い自動車やガレージの中のバイクのパーツの山だったり、あるいはドキドキする心臓や健康のためのエクササイズ
のプランかもしれません。オブジェクトにはそれぞれ固有の振る舞いがあります。オブジェクトどうしのやり取り
があらかじめ決まっている場合もありますが、あなたの配偶者が思いがけず猫を踏んでしまったことが、
みんなの心臓をドキドキさせたり、あなたにエクササイズのプランを再評価させるような事態だって起こりえます。

オブジェクトの世界では、新たな振る舞いの組み合わせは自然に現れます。`spouse_steps_on_cat` という
手続きを明示的にコーディングする必要はありません。みなさんがすべきことは、歩く配偶者オブジェクトと
踏まれるのが嫌いな猫オブジェクトを作ることだけです。そして、このふたつのオブジェクトをひとつの部屋に
押し込むと、思いがけない振る舞いの組み合わせが出現します。

この本は、オブジェクト指向なソフトウェアのデザインについて書かれています。
そして、世界はオブジェクトどうしの自発的なやり取りの連続からできているという視点で書かれています。
オブジェクト指向なデザイン（OOD: Object-oriented design）は、みなさんの世界についての認識をシフトさせます。
あらかじめ定義された手続きの集まりとしての世界から、オブジェクトどうしでやり取りされるメッセージの連続として
の世界へのシフトです。OOD で失敗するのは、コーディング技術が不足しているからだと言われそうですが、
現実には世界についての認識が間違っているから失敗するのです。オブジェクト指向なデザインを学ぶには、
まずオブジェクトの世界にどっぷり浸る必要があります。オブジェクト指向な世界観を一度体得してしまえば、
あとはおのずとついてきます。

この本では、浸礼のプロセスを通じてみなさんをオブジェクト指向なデザインへと案内していきます。
本章は、OODについての全般的な議論から出発します。まず、デザイン一般について議論したあとで、
いつデザインすべきか、それをどう判断すべきかについてお話しします。
そして最後に、オブジェクト指向プログラミングについて概観して本書で使われる用語を定義します。

#### デザインのススメ

あるソフトウェアが作られるのには何らかの理由があります。トリビアルなゲームであろうと放射線治療の
プログラムであろうと、ターゲットのアプリケーションにすべてが凝縮されています。動くソフトウェア
を生み出すのにもっとも費用対効果の高い方法が苦痛に満ちたプログラミングならば、プログラマはただ黙って
耐え忍ぶか別の仕事を探すことになるでしょう。

幸いにもみなさんは喜びと生産性、いずれかの二者択一に迫られることはありません。コードを書くことが喜びと
なるようなプログラミングテクニックと費用対効果の高いソフトウェア開発を実現するテクニックとは
オーバーラップするのです。オブジェクト指向デザインのテクニックは、仕事への意欲とプログラミングにまつわる技術上の
ディレンマを解決してくれます。このテクニックは書くことが楽しくなるコードによって費用対効果の高いソフトウェアを
生み出します。


##### デザインが解決する問題

あたらしいアプリケーションを書くとしましょう。アプリケーションはすべての要件を完全に、
そして正確に実装しているとします。そしてもうひとつこう仮定しましょう。一度書かれたアプリケーション
は決して変更されない、と。

このような状況ではデザインが問題になることはありません。サーカスのパフォーマが摩擦も重力もない世界で
皿回しをするように、プログラムしたアプリケーションが一度動き出せばあなたはその場から少し離れ、アプリケーションが永遠に
動き続ける様子を眺めます。どんなに不安定に見えたとしてもコードの皿は回り続け、
ふらふら旋回しながらも決して落ちることはないのです。

そう、何も変わらない限りは。

残念ながら何かが変化します。いつもそうです。カスタマは最初から本当に自分が欲しいものが何か分かりませんし、
本当に伝えたいことは言えないものなのです。みなさんはカスタマのニーズを理解しておらず、どうすればより良くなるのかを
その都度学んでいます。どこから見てもパーフェクトなアプリケーションであっても安泰ということはありません。
アプリケーションが大成功すると、みんなそれにもっと期待するようになります。そうなると変更はさけられません。
これはいたるところで言えることであり、普遍的で不可避なことなのです。

変化する要件は摩擦と重力に相当します。摩擦と重力は慎重に錬成された計画に突如、予期せぬプレッシャ
をかけます。デザインが重要なのは変更の必要性からです。

変更が容易なアプリケーションは書くのが楽しいですし、大きくすることが喜びとなります。柔軟で適応性が高いからです。
変更に抵抗するアプリケーションはまったく逆です。どんな変更も高くつき、変更すればつぎのコストを生みます。
変更しにくいアプリケーションはほとんどの場合、仕事していても楽しくありません。そのうちでも最悪なものは
だんだん恐怖映画じみてきて、不運なプログラマであるみなさんは焼き物の皿が床に砕け落ちる音を聞かれまいとして、
回転する皿の間を血眼になって駆け回るのです。

##### なぜ変更は難しいのか

アプリケーション全体としての振る舞いは、アプリケーションを構成する個々の部品間のやり取りから生まれます。
これらの部品が「オブジェクト」です。そして、オブジェクト間のやり取りは「メッセージ」として具現化します。
正しいメッセージを正しいオブジェクトに送り届けるには、送信者は受信者（レシーバ）についてあらかじめ知って
いなければなりません。しかしこの知識は、送信者と受信者との間に依存関係をもたらし依存関係は変更への足枷
になります。

オブジェクト指向デザインの関心は依存関係の管理にあります。オブジェクト指向デザインは依存関係を調整し
オブジェクトの変更を許容するコーディングテクニックを集めたものです。デザインが不在で、オブジェクト同士
が互いに知りすぎているような依存関係の放置された状況はアプリケーションに非常に大きなダメージを与えてしまいます。
あるひとつのオブジェクトを変更するとその協力者である他のオブジェクトまで変更しなくてはならなくなり、
さらにその仲間へとどんどん広がっていきます。些細な変更を震源としてダメージが放射状にオブジェクトへと
波及していき、終わって見れば変更しなかったコードはなかったといったような始末です。

知りすぎたオブジェクトたちは、自分たちの存在する世界について過剰な期待を抱くようになります。
彼らは口やかましくなり「あるべき」（"just so"）モノを要求し始めます。こうした期待は、期待する彼ら自身を
制約してしまいます。さまざまなコンテキストで再利用されることを、オブジェクトたちは拒みます。
こうしたオブジェクトはテストが難しく、同じように具合の悪いオブジェクトのコピー元になりがちなのです。

小さなアプリケーションであれば、まずいデザインも生き残ることができます。すべてのオブジェクトが互いに密接に
絡み合っていても、みなさんが頭のなかでその様子をパッとイメージできるのなら、まだそのアプリケーションを
アップデートしていくことは可能でしょう。「小さな」アプリケーションのまずいデザインが問題になるのは、
そのアプリケーションが成功して「大きな」アプリケーションのまずいデザインになった時です。そうしたアプリケーション
はタールピット（タールの池）のようで、跡形なく溺れ死にそうで恐ろしいから誰もそこに足をふみ入れようとはしません。
シンプルであるはずの変更がアプリケーションのあちこちに連鎖し、コードを破壊しまくり広範囲に書き直さなくては
ならない破目に陥ります。テストは十字砲火の真っただ中にさらされ、救いであるどころか妨害であるかのように扱われ始めます。

##### 実践的デザインとは

アプリケーションはコードの寄せ集めです。デザインとはコードをアレンジすることです。デザインについての考え方が
共通している面識のない二人のプログラマが、同一の問題を異なるコードアレンジで解決することはありえます。
デザインは、同じような訓練を受けた労働者（ワーカー）が規格品を作るためのコードの寄せ集めではありません。
デザインは、考え方の近いアーティストたちがカスタムなアプリケーションを生み出すためのスタジオ（アトリエ）です。
だからデザインはアートです。コードをアレンジするアートなのです。

デザインの難しさのひとつは、あらゆる問題が抱える二つの側面に起因します。今日デリバリするフィーチャだけのために
コードを書いてはいけません。フィーチャだけのためではなくコードを将来変更されるものとして書かなくてはなりません。
ベータ版を拡張していくと、いつしか変更のコストが初期開発コストを上回ってしまいます。デザインの原則はお互いに
オーバーラップしており、あらゆる問題は時間とともに変化していく宿命にあるので、いざデザインしようすると考えられる
ソリューションの数の多さに目が眩むことでしょう。みなさんの仕事は「総合」のひとつです。アプリケーションの要件を
すべて理解したうえで妥当なコストと採用すべきデザインを組み合わせます。そして現時点で費用効率が高く将来も高いで
あろうコードをどうアレンジしたらよいのか頭を絞ります。

未来を考慮に入れることは、通常、プログラミングの領域外にあると考えられている霊能力を頼りにすることと思われる
かもしれません。もちろんそんなことはありません。デザインが考慮する未来は、未知の要件を予測することでもなければ、
未知の要件のうちからひとつ選んでいま実装することでもありません。プログラマは霊能者ではありません。
未来の特定の要件を予測しようとするデザインは、大抵失敗します。実践的なデザインはみなさんのアプリケーションに
これから起こることを予測したりはしません。何かが起こるということ、そしてそれは現時点では何かわからない
ということを受け入れるだけです。未来を推測しないことは、来るべき状況に適応するオプションをキープしてくれます。
選択しないことは、動ける余地（あそび）を残してくれます。

デザインの目的は「あとから」もデザインできるようにしておくことであり、デザインすることの第１のゴールは、
変更のコストを下げることにあります。

#### デザイン・ツール

デザインとは決まりきったルール集を遵守することではありません。デザインとは枝分かれする路を辿る旅であり、
いま取った選択が、いくつかの可能性を閉じ、そして別の可能性を開いていくプロセスなのです。デザインするとは、
分岐点がディシジョンポイントになっている要件の迷宮をさまよい歩くことなのです。

彫刻家ののみとヤスリのように、オブジェクト指向デザイナにもツールがあります。それが原則とパターンです。


##### デザインの原則

SOLID は Michael Feathers が考案し、Robert Martin が普及させた言葉で、オブジェクト指向デザインの
最もよく知られた五つの原則の頭文字に由来します。

* Single Responsibility（単一責務原則）
* Open-Closed（開放／閉鎖原則）
* Liskov Substitution（リスコフの置換原則）
* Interface Segregation（インターフェイス分掌原則）
* Dependency Inversion（依存転地原則）

これら以外に、Andy Hunt と Dave Thomas が提唱する DRY（Don't Repeat Yourself）やノースイースタン大学の
デメテルプロジェクトの成果である、デメテルの法則（LoD: Law of Demeter）が知られています。

原則それ自体は本書を通じて触れていくことにして、さしあったての疑問は：「これらの原則は地球上のどこからやってきたのか？」。
原則は実験的に証明可能な価値があるのでしょうか？それとも単なるだれかの一意見に過ぎず、耳を貸すも貸さないも
みなさんの自由なのでしょうか？そもそも誰がこうした原則を唱えているのでしょう？

原則はすべて、コードを書く主体が下した選択に起源があります。オブジェクト指向なプログラマは早い時期から、
自分たちを楽にしてくれるコードアレンジとそうでないコードがあることに気づいていました。こうした経験から、
どうすれば良いコードが書けるのか自分たちの考えを発展させていったのです。

そのうちアカデミックな人たちが首をつっこんできて、論文を書く必要性もあり、よいコードを「グッドネス」と形容する
ことにしました。それは賞賛に値する目論見でした。ものごとを勘定する、つまりコードの「メトリクス」を計測してそのメトリクスと
アプリケーションの品質の良し悪しとの相関を分析することができるのなら（そのためには客観的な指標が必要です）、
コスト減に寄与することはより多く、コスト増をもたらすことはより少なくすることが可能になります。
品質を測定できるという事実は、オブジェクト指向デザインを終わりのない議論から計量可能な科学へと変化させるはずです。

1990 年代に Chidamber と Kemerer と Basilis が行ったのはまさにこれでした。オブジェクト指向なアプリケーションを取り上げ、
コードの品質分析を試みたのです。かれらが行ったのは命名と計測でした。クラス全体の大きさ、クラス間の膠着度、継承階層の深さと広がり、
メッセージの送信により呼び出されたメソッドの数などです。重要と思われるコードアレンジをピックアップし、その呼び名を
考案しました。そしてコードのメトリクスとアプリケーション品質との相関を分析したのです。そして研究結果が示したのは、
特定のコードアレンジのテクニックと高品質なコードには相関関係があることでした。

研究結果がデザインの原則の有効性を証明したとしても、経験豊かなプログラマにとっては眉唾ものと受け止められるでしょう。
かれらの先駆的な研究は大学院生たちの書いた非常に小さなアプリケーションを対象としていました。この点だけとっても、
研究結果を鵜呑みにするのは控えるべきかもしれません。研究対象のアプリケーションコードは現実のオブジェクト指向アプリケーション
の典型とはいえないのではないでしょうか。

しかしながら、この留保は不要なのです。2001 年 Laing と Coleman は NASA ゴダード宇宙飛行センターで利用されている
アプリケーション（ロケット科学）を調査しました。目的は明確で、「ソフトウェアのクオリティの良し悪しを決めるコードの書き方」
を発見することでした。二人はクオリティの異なる３つのアプリケーションを調査対象にしました。そのうちの１つは、クラスが 1617 個あり、
50 万行を超えるコードで記述されていました。二人の調査結果は先の Chidamber らの結論を裏付けるものであり、デザイン原則の
重要性を確証するものでした。みなさんがこうした研究成果をご存知ないとしても、その結論を信じて間違いはありません。
良いデザインの原則は計測可能であって、原則に従うことはコードを改善するのです。

##### デザインパターン

「原則」に加え、オブジェクト指向デザインには「パターン」があります。通称 Gang of Four（GoF）で知られる、Erich Gamma、
Richard Helm、Ralph Johnson、Jon Vlissides の４人は、1995 年にパターンについての先駆的な仕事を手がけました。
その『デザインパターン』は、パターンを「オブジェクト指向ソフトウェアのデザインにおける、問題解決のシンプルで
エレガントなソリュション集」として描出し、パターンを導入することでソフトウェアは、より柔軟で、モジュール化され、再利用可能で、
しかも理解しやすくなると主張しました。

デザインパターンという考えはとてもパワフルです。共通の問題に名前を付け共通の方法で問題を解決するという発想は、
曖昧な対象に輪郭を与えてくれました。デザインパターンはあらゆる世代のプログラマたちにコミュニケーションとコラボレーションの
本当の意味を教えてくれました。

パターンはデザインするすべての人のツールボックスにその居場所があります。よく知られたパターンは問題を解決してくれるオープンソース
のプログラムに匹敵します。しかしパターンの普及は駆け出しプログラマによるパターンの乱用を誘発しました。本人は自分の正しさを信じ込んで、
正しいパターンをお門違いな問題解決に適用してしまいます。パターンの誤用は、複雑で混乱したコードを生みだします。
パターンが悪いのではありません。ツールを利用することでツールが間違うことはありません。ユーザがツールの使い方をマスター
しなければならないのです。

本書はパターンについて書かれたものではありませんが、みなさんがパターンを理解する手助けをし、パターンを正しく利用するための
知識を提供します。

### デザインするということ

デザインの原則とパターンの発見と広まりによって、オブジェクト指向プログラミングの問題はすべて解決されたかのように見えたかもしれません。
基本となるルールが知られたいま、オブジェクト指向なソフトウェアをデザインすることのどこがそんなに難しいことなのでしょうか？

いや、むしろ難しくなったといえるでしょう。ソフトウェアを注文家具に例えるなら、原則とパターンは木工用道具のようなものです。
出来上がるソフトウェアがどのようなものか分かっていたとしても、それでソフトウェアが作れる訳ではありません。
アプリケーションがこの世に姿を現すのは、プログラマがツールを使ってそれを作ったからです。最終的に美しいキャビネットになるのか、
いまにも壊れそうな椅子になるのかは、プログラマがどれだけツールを使いこなせるかにかかっています。

#### デザインはどのように失敗するか

デザインが失敗するのはなによりもまず、デザインが不在なことに起因します。プログラマは初め、デザインをほとんど知りません。
ですがそれは仕事の妨げにはならないものです。デザインのデの字を知らなくても動くアプリケーションを書くことはできるのですから。

オブジェクト指向言語のうちのいくつかは他の言語と比べてこの傾向が強く、Ruby のようにとっつきやすい言語は特に脆弱と言えます。
Ruby はとてもフレンドリーな言語です。大抵の人は定期実行タスクの自動化スクリプトを書くことができますし、Ruby on Rails のような独特
なフレームワークにより、Web アプリケーション開発がすべてのプログラマにとって非常に身近なものになりました。
Ruby のシンタックスはとても親切にできていて自分の考えをロジカルに組み立てることができる人なら誰もが、動くアプリケーション
を作ることができます。オブジェクト指向デザインを知らないプログラマでも Ruby を使えば結構うまくいくものです。

ところが、うまくいっていてもデザインされていないアプリケーションは、自らの崩壊の種を持ち込んでしまいます。こうしたアプリケーション
は書くのは簡単ですが、変更は徐々に不可能になっていきます。プログラマの過去の経験は未来を予測できません。当初の痛みの伴わない
開発の誓いが徐々に崩れていき、楽観は絶望へと変わります。そうして、プログラマは変更要求ひとつひとつにこう応じるようになります。
「わかりました。そのフィーチャを実装はできますがいろんなところに影響がでますよ」と。

もう少し経験を積んだプログラマたちは、これとはまた違うデザイン上の失敗に遭遇します。彼らはオブジェクト指向デザインのテクニックを
意識してはいますが、それをどうやって現実に適用すればよいかまだ理解していません。


> under development


#### まとめ

それなりに長期間動いているアプリケーション、つまり成功しているアプリケーションが遭遇する最大の
問題は変更への対処です。変更に対して手際よく対処できるようコードをアレンジすることはデザインの仕事です。
デザインでいちばんわかりやすい要素は基本原則とパターンですが、基本原則をいくら正しく適用しても、
パターンをいくら適切に使っても変更しやすいアプリケーションの開発を保証してくれたりはしません。

メトリクスは、アプリケーションがどの程度オブジェクト指向デザインの基本原則をフォローしているのか
教えてくれます。メトリクスの悪いアプリケーションは将来何らかの問題に出くわすでしょう。
しかし、メトリクスが良いからといって楽観はできません。問題を起こすようなデザインのメトリクスが良い
場合もあるでしょうし、メトリクスが良くても変更のコストは高いままかもしれません。

良いデザインの秘訣は、デザインの理論をきちんと習得すること、そして習得した理論を適切に、
つまり正しいタイミングで正しい量を適用することです。デザインの良し悪しは理論を実践に翻訳する
みなさんの力量にかかっています。

理論と実践の違いは何でしょう？

理論には何もありません。もし理論が実践ならば、オブジェクト指向デザインのルールを習得し、ひたすらルールを
適用していけば、その日からパーフェクトなコードを書くことができるでしょう。そこでみなさんの仕事は完了です。

理論がいくらそれを正しいと主張したところで、その主張をよりよく知っているのは実践のほうです。
理論とはちがい、実践は自らの手を汚します。煉瓦を積み上げ、橋を架け、コードを書くのは実践です。
実践は、変化と混乱と不確実に満ちた現実の世界に生きています。いくつもの選択肢を秤にかけ、苦々しくありながらも、
ときにより邪悪でないほうを選択しなければならないような状況に遭遇します。身をかわし、隠れ、借りた金で返済したり
するのが実践です。いまある資源でベストを尽くし身過ぎ世過ぎすることが実践です。

理論は有益であり必要というのが本章の主張でした。ですがもう理論は十分です。実践に移りましょう。

