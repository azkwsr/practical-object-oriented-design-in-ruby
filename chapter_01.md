## 1 章

### オブジェクト指向デザイン

世界は手続き的です。時間は未来に向かって流れ、出来事がひとつまたひとつと生起しては消えていきます。
みなさんの朝の手続きは、起床して、歯を磨き、コーヒーを淹れて、服を着て、仕事に取り掛かるといった感じでしょうか。
このような行為は手続き型のソフトウェアでモデリングすることができます。みなさんはそれぞれの行為の順番を知っていて、
行為が何をするのかコードで書くことができますし、自分の意図でひとつひとつの行為を並べることができるからです。

世界はオブジェクト指向的でもあります。みなさんが関わるオブジェクトは、配偶者（"spouse"）や猫（"cat"）、
古い自動車やガレージの中のバイクのパーツの山だったり、あるいはドキドキする心臓や健康のためのエクササイズ
のプランかもしれません。オブジェクトにはそれぞれ固有の振る舞いがあります。オブジェクトどうしのやり取り
があらかじめ決まっている場合もありますが、あなたの配偶者が思いがけず猫を踏んでしまったことが、
みんなの心臓をドキドキさせたり、あなたにエクササイズのプランを再評価させるような事態だって起こりえます。

オブジェクトの世界では、新たな振る舞いの組み合わせは自然に現れます。`spouse_steps_on_cat` という
手続きを明示的にコーディングする必要はありません。みなさんがすべきことは、歩く配偶者オブジェクトと
踏まれるのが嫌いな猫オブジェクトを作ることだけです。そして、このふたつのオブジェクトをひとつの部屋に
押し込むと、思いがけない振る舞いの組み合わせが出現します。

この本は、オブジェクト指向なソフトウェアのデザインについて書かれています。
そして、世界はオブジェクトどうしの自発的なやり取りの連続からできているという視点で書かれています。
オブジェクト指向なデザイン（OOD: Object-oriented design）は、みなさんの世界についての認識をシフトさせます。
あらかじめ定義された手続きの集まりとしての世界から、オブジェクトどうしでやり取りされるメッセージの連続として
の世界へのシフトです。OOD で失敗するのは、コーディング技術が不足しているからだと言われそうですが、
現実には世界についての認識が間違っているから失敗するのです。オブジェクト指向なデザインを学ぶには、
まずオブジェクトの世界にどっぷり浸る必要があります。オブジェクト指向な世界観を一度体得してしまえば、
あとはおのずとついてきます。

この本では、浸礼のプロセスを通じてみなさんをオブジェクト指向なデザインへと案内していきます。
本章は、OODについての全般的な議論から出発します。まず、デザイン一般について議論したあとで、
いつデザインすべきか、それをどう判断すべきかについてお話しします。
そして最後に、オブジェクト指向プログラミングについて概観して本書で使われる用語を定義します。

#### デザインのススメ

あるソフトウェアが作られるのには何らかの理由があります。トリビアルなゲームであろうと放射線治療の
プログラムであろうと、ターゲットのアプリケーションにすべてが凝縮されています。動くソフトウェア
を生み出すのにもっとも費用対効果の高い方法が苦痛に満ちたプログラミングならば、プログラマはただ黙って
耐え忍ぶか別の仕事を探すことになるでしょう。

幸いにもみなさんは喜びと生産性、いずれかの二者択一に迫られることはありません。コードを書くことが喜びと
なるようなプログラミングテクニックと費用対効果の高いソフトウェア開発を実現するテクニックとは
オーバーラップするのです。オブジェクト指向デザインのテクニックは、仕事への意欲とプログラミングにまつわる技術上の
ディレンマを解決してくれます。このテクニックは書くことが楽しくなるコードによって費用対効果の高いソフトウェアを
生み出します。


##### デザインが解決する問題

あたらしいアプリケーションを書くとしましょう。アプリケーションはすべての要件を完全に、
そして正確に実装しているとします。そしてもうひとつこう仮定しましょう。一度書かれたアプリケーション
は決して変更されない、と。

このような状況ではデザインが問題になることはありません。サーカスのパフォーマが摩擦も重力もない世界で
皿回しをするように、プログラムしたアプリケーションが一度動き出せばあなたはその場から少し離れ、アプリケーションが永遠に
動き続ける様子を眺めます。どんなに不安定に見えたとしてもコードの皿は回り続け、
ふらふら旋回しながらも決して落ちることはないのです。

そう、何も変わらない限りは。

残念ながら何かが変化します。いつもそうです。カスタマは最初から本当に自分が欲しいものが何か分かりませんし、
本当に伝えたいことは言えないものなのです。みなさんはカスタマのニーズを理解しておらず、どうすればより良くなるのかを
その都度学んでいます。どこから見てもパーフェクトなアプリケーションであっても安泰ということはありません。
アプリケーションが大成功すると、みんなそれにもっと期待するようになります。そうなると変更はさけられません。
これはいたるところで言えることであり、普遍的で不可避なことなのです。

変化する要件は摩擦と重力に相当します。摩擦と重力は慎重に錬成された計画に突如、予期せぬプレッシャ
をかけます。デザインが重要なのは変更の必要性からです。

変更が容易なアプリケーションは書くのが楽しいですし、大きくすることが喜びとなります。柔軟で適応性が高いからです。
変更に抵抗するアプリケーションはまったく逆です。どんな変更も高くつき、変更すればつぎのコストを生みます。
変更しにくいアプリケーションはほとんどの場合、仕事していても楽しくありません。そのうちでも最悪なものは
だんだん恐怖映画じみてきて、不運なプログラマであるみなさんは焼き物の皿が床に砕け落ちる音を聞かれまいとして、
回転する皿の間を血眼になって駆け回るのです。

##### なぜ変更は難しいのか

アプリケーション全体としての振る舞いは、アプリケーションを構成する個々の部品間のやり取りから生まれます。
これらの部品が「オブジェクト」です。そして、オブジェクト間のやり取りは「メッセージ」として具現化します。
正しいメッセージを正しいオブジェクトに送り届けるには、送信者は受信者（レシーバ）についてあらかじめ知って
いなければなりません。しかしこの知識は、送信者と受信者との間に依存関係をもたらし依存関係は変更への足枷
になります。

オブジェクト指向デザインの関心は依存関係の管理にあります。オブジェクト指向デザインは依存関係を調整し
オブジェクトの変更を許容するコーディングテクニックを集めたものです。デザインが不在で、オブジェクト同士
が互いに知りすぎているような依存関係の放置された状況はアプリケーションに非常に大きなダメージを与えてしまいます。
あるひとつのオブジェクトを変更するとその協力者である他のオブジェクトまで変更しなくてはならなくなり、
さらにその仲間へとどんどん広がっていきます。些細な変更を震源としてダメージが放射状にオブジェクトへと
波及していき、終わって見れば変更しなかったコードはなかったといったような始末です。

知りすぎたオブジェクトたちは、自分たちの存在する世界について過剰な期待を抱くようになります。
彼らは口やかましくなり「あるべき」（"just so"）モノを要求し始めます。こうした期待は、期待する彼ら自身を
制約してしまいます。さまざまなコンテキストで再利用されることを、オブジェクトたちは拒みます。
こうしたオブジェクトはテストが難しく、同じように具合の悪いオブジェクトのコピー元になりがちなのです。

小さなアプリケーションであれば、まずいデザインも生き残ることができます。すべてのオブジェクトが互いに密接に
絡み合っていても、みなさんが頭のなかでその様子をパッとイメージできるのなら、まだそのアプリケーションを
アップデートしていくことは可能でしょう。「小さな」アプリケーションのまずいデザインが問題になるのは、
そのアプリケーションが成功して「大きな」アプリケーションのまずいデザインになった時です。そうしたアプリケーション
はタールピット（タールの池）のようで、跡形なく溺れ死にそうで恐ろしいから誰もそこに足をふみ入れようとはしません。
シンプルであるはずの変更がアプリケーションのあちこちに連鎖し、コードを破壊しまくり広範囲に書き直さなくては
ならない破目に陥ります。テストは十字砲火の真っただ中にさらされ、救いであるどころか妨害であるかのように扱われ始めます。

##### 実践的デザインとは

アプリケーションはコードの寄せ集めです。デザインとはコードをアレンジすることです。デザインについての考え方が
共通している面識のない二人のプログラマが、同一の問題を異なるコードアレンジで解決することはありえます。
デザインは、同じような訓練を受けた労働者（ワーカー）が規格品を作るためのコードの寄せ集めではありません。
デザインは、考え方の近いアーティストたちがカスタムなアプリケーションを生み出すためのスタジオ（アトリエ）です。
だからデザインはアートです。コードをアレンジするアートなのです。

デザインの難しさのひとつは、あらゆる問題が抱える二つの側面に起因します。今日デリバリするフィーチャだけのために
コードを書いてはいけません。フィーチャだけのためではなくコードを将来変更されるものとして書かなくてはなりません。
ベータ版を拡張していくと、いつしか変更のコストが初期開発コストを上回ってしまいます。デザインの原則はお互いに
オーバーラップしており、あらゆる問題は時間とともに変化していく宿命にあるので、いざデザインしようすると考えられる
ソリューションの数の多さに目が眩むことでしょう。みなさんの仕事は「総合」のひとつです。アプリケーションの要件を
すべて理解したうえで妥当なコストと採用すべきデザインを組み合わせます。そして現時点で費用効率が高く将来も高いで
あろうコードをどうアレンジしたらよいのか頭を絞ります。

未来を考慮に入れることは、通常、プログラミングの領域外にあると考えられている霊能力を頼りにすることと思われる
かもしれません。もちろんそんなことはありません。デザインが考慮する未来は、未知の要件を予測することでもなければ、
未知の要件のうちからひとつ選んでいま実装することでもありません。プログラマは霊能者ではありません。
未来の特定の要件を予測しようとするデザインは、大抵失敗します。実践的なデザインはみなさんのアプリケーションに
これから起こることを予測したりはしません。何かが起こるということ、そしてそれは現時点では何かわからない
ということを受け入れるだけです。未来を推測しないことは、来るべき状況に適応するオプションをキープしてくれます。
選択しないことは、動ける余地（あそび）を残してくれます。

デザインの目的は「あとから」もデザインできるようにしておくことであり、デザインすることの第１のゴールは、
変更のコストを下げることにあります。

#### デザイン・ツール

デザインとは決まりきったルール集を遵守することではありません。デザインとは枝分かれする路を辿る旅であり、
いま取った選択が、いくつかの可能性を閉じ、そして別の可能性を開いていくプロセスなのです。デザインするとは、
分岐点がディシジョンポイントになっている要件の迷宮をさまよい歩くことなのです。

彫刻家ののみとヤスリのように、オブジェクト指向デザイナにもツールがあります。それが原則とパターンです。


##### デザインの原則

SOLID は Michael Feathers が考案し、Robert Martin が普及させた言葉で、オブジェクト指向デザインの
最もよく知られた五つの原則の頭文字に由来します。

* Single Responsibility（単一責務原則）
* Open-Closed（開放／閉鎖原則）
* Liskov Substitution（リスコフの置換原則）
* Interface Segregation（インターフェイス分掌原則）
* Dependency Inversion（依存転地原則）

これら以外に、Andy Hunt と Dave Thomas が提唱する DRY（Don't Repeat Yourself）やノースイースタン大学の
デメテルプロジェクトの成果である、デメテルの法則（LoD: Law of Demeter）が知られています。

原則それ自体は本書を通じて触れていくことにして、さしあったての疑問は：「これらの原則は地球上のどこからやってきたのか？」。
原則は実験的に証明可能な価値があるのでしょうか？それとも単なるだれかの一意見に過ぎず、耳を貸すも貸さないも
みなさんの自由なのでしょうか？そもそも誰がこうした原則を唱えているのでしょう？

原則はすべて、コードを書く主体が下した選択に起源があります。オブジェクト指向なプログラマは早い時期から、
自分たちを楽にしてくれるコードアレンジとそうでないアレンジがあることに気づいていました。こうした経験から、
どうすれば良いコードが書けるのか自分たちの考えを発展させていったのです。

そのうちアカデミックな人たちが首をつっこんできて、論文を書く必要性もあり、よいコードを「グッドネス」と形容する
ことにしました。それは賞賛に値する目論見でした。ものごとを勘定する、つまりコードの「メトリクス」を計測してそのメトリクスと
アプリケーションの品質の良し悪しとの相関を分析することができるのなら（そのためには客観的な指標が必要です）、
コスト減に寄与することはより多く、コスト増をもたらすことはより少なくすることが可能になります。
品質を測定できるという事実は、オブジェクト指向デザインを終わりのない議論から計量可能な科学へと変化させるはずです。

1990 年代に Chidamber と Kemerer と Basilis が行ったのはまさにこれでした。オブジェクト指向なアプリケーションを取り上げ、
コードの品質分析を試みたのです。かれらが行ったのは命名と計測でした。クラス全体の大きさ、クラス間の膠着度、継承階層の深さと広がり、
メッセージの送信により呼び出されたメソッドの数などです。重要と思われるコードアレンジをピックアップし、その呼び名を
考案しました。そしてコードのメトリクスとアプリケーション品質との相関を分析したのです。そして研究結果が示したのは、
特定のコードアレンジのテクニックと高品質なコードには相関関係があることでした。

研究結果がデザインの原則の有効性を証明したとしても、経験豊かなプログラマにとっては眉唾ものと受け止められるでしょう。
かれらの先駆的な研究は大学院生たちの書いた非常に小さなアプリケーションを対象としていました。この点だけとっても、
研究結果を鵜呑みにするのは控えるべきかもしれません。研究対象のアプリケーションコードは現実のオブジェクト指向アプリケーション
の典型とはいえないのではないでしょうか。

しかしながら、この留保は不要なのです。2001 年 Laing と Coleman は NASA ゴダード宇宙飛行センターで利用されている
アプリケーション（ロケット科学）を調査しました。目的は明確で、「ソフトウェアのクオリティの良し悪しを決めるコードの書き方」
を発見することでした。二人はクオリティの異なる３つのアプリケーションを調査対象にしました。そのうちの１つは、クラスが 1617 個あり、
50 万行を超えるコードで記述されていました。二人の調査結果は先の Chidamber らの結論を裏付けるものであり、デザイン原則の
重要性を確証するものでした。みなさんがこうした研究成果をご存知ないとしても、その結論を信じて間違いはありません。
良いデザインの原則は計測可能であって、原則に従うことはコードを改善するのです。

##### デザインパターン

「原則」に加え、オブジェクト指向デザインには「パターン」があります。通称 Gang of Four（GoF）で知られる、Erich Gamma、
Richard Helm、Ralph Johnson、Jon Vlissides の４人は、1995 年にパターンについての先駆的な仕事を手がけました。
その『デザインパターン』は、パターンを「オブジェクト指向ソフトウェアのデザインにおける、問題解決のシンプルで
エレガントなソリュション集」として描出し、パターンを導入することでソフトウェアは、より柔軟で、モジュール化され、再利用可能で、
しかも理解しやすくなると主張しました。

デザインパターンという考えはとてもパワフルです。共通の問題に名前を付け共通の方法で問題を解決するという発想は、
曖昧な対象に輪郭を与えてくれました。デザインパターンはあらゆる世代のプログラマたちにコミュニケーションとコラボレーションの
本当の意味を教えてくれました。

パターンはデザインするすべての人のツールボックスにその居場所があります。よく知られたパターンは問題を解決してくれるオープンソース
のプログラムに匹敵します。しかしパターンの普及は駆け出しプログラマによるパターンの乱用を誘発しました。本人は自分の正しさを信じ込んで、
正しいパターンをお門違いな問題解決に適用してしまいます。パターンの誤用は、複雑で混乱したコードを生みだします。
パターンが悪いのではありません。ツールを利用することでツールが間違うことはありません。ユーザがツールの使い方をマスター
しなければならないのです。

本書はパターンについて書かれたものではありませんが、みなさんがパターンを理解する手助けをし、パターンを正しく利用するための
知識を提供します。

### デザインするということ

デザインの原則とパターンの発見と広まりによって、オブジェクト指向プログラミングの問題はすべて解決されたかのように見えたかもしれません。
基本となるルールが知られたいま、オブジェクト指向なソフトウェアのデザインはそんなに難しいことなのでしょうか？

いや、むしろ難しくなったといえるでしょう。ソフトウェアを注文家具に例えるなら、原則とパターンは木工用道具のようなものです。
出来上がるソフトウェアがどのようなものか分かっていたとしても、それでソフトウェアが作れる訳ではありません。
アプリケーションがこの世に姿を現すのは、プログラマがツールを使ってそれを作ったからです。最終的に美しいキャビネットになるのか、
いまにも壊れそうな椅子になるかは、プログラマがどれだけツールを使いこなせるかにかかっています。

#### デザインはどのように失敗するのか

デザインが失敗するのはなによりもまず、デザインが不在なことに起因します。プログラマは初め、デザインをほとんど知りません。
ですがそれは仕事の妨げにはならないものです。デザインのデの字を知らなくても動くアプリケーションは書けるからです。

オブジェクト指向言語のうちのいくつかは、他の言語と比べてこの傾向が強く、Ruby のようにとっつきやすい言語は特に脆弱と言えます。
Ruby はとてもフレンドリな言語です。大抵の人は、定期実行タスクの自動化スクリプトを簡単に書くことができますし、
Ruby on Rails のような独特なフレームワークにより、Web アプリケーション開発がすべてのプログラマにとって非常に身近なものになりました。
Ruby のシンタックスはとても親切にできていて、自分の考えをロジカルに組み立てることができる人なら誰でも動くアプリケーション
を作ることができます。オブジェクト指向デザインを知らないプログラマでも Ruby を使えば結構うまくいきます。

ところが、うまくはいっていてもデザインされていないアプリケーションは自らの崩壊の種を持ち込んでしまいます。こうしたアプリケーション
は、書くのは簡単ですが変更は徐々に不可能になっていきます。プログラマの過去の経験は未来を予測できません。当初の痛みの伴わない
開発の誓いが徐々に崩れていき、楽観は絶望へと変わります。そうして、プログラマは変更要求にこう応じるようになります。
「わかりました。そのフィーチャは実装できますがいろんなところに影響がでます」。

もう少し経験を積んでいるプログラマたちは、これとはまた違ったかたちでデザインに失敗します。彼らはオブジェクト指向デザインのテクニック
を意識していますが、それをどうやって適用すればよいのかよく理解できていません。その意気込みが、逆に彼らを過剰なデザインという罠に嵌め込みます。
生半可な知識ほど危険なものはありません。知識が増え、その見返りを望むようになるにしたがって、彼らはむやみやたらに「デザイン」してしまいます。
デザイン狂のあまり、パターンを適切に適用しないどころか、何もないところにまでパターンを発見してしまいます。彼らが作り出すのは、複雑で美しいコードのお城です。
そして自分たちが城壁に囲まれ閉じ込められていることを知って苦しむのです。あなたはこうしたプログラマを知っているかもしれません。
彼らは変更要求にこう応えるでしょう。「いや、そのフィーチャは追加できませんね。そんなフィーチャを追加できるようにはデザインしていなんです」。

最後に、オブジェクト指向デザインが失敗するのは、デザインすることとプログラミングすることとが分離してしまったときです。
デザインはフィードバック・ループに基づいた絶え間のない発見のプロセスです。フィードバック・ループは時機を得ていて、徐々に膨らんでいくほうがいいのです。
ですから、[アジャイル・ソフトウェア・ムーブメント](http://agilemanifesto.org/)の反復的（イテレイティブ）なテクニックは、よくデザインされた
オブジェクト指向アプリケーションの開発と非常に相性が良いのです。アジャイル開発のイテレイティブな特性は、デザインを定期的に見直し、
無理なくデザインを発展させてくれます。デザインがどこか遠くから聞こえてくる啓示ならば、見直すことなどなにもありませんが、啓示の内容を理解し
それをコードに固めるのに早々に失敗することでしょう。どこかの「専門家」がデザインしたアプリケーションを書かされているプログラマたちは
こう言うはずです。「まあ、これを書いたのは確かに自分だけど、これはあなたが本当に欲しいものではないからいずれ後悔すると思うよ」。

#### いつデザインするのか

アジャイルでは、顧客はソフトウェアをあらかじめ定義することができないので、すぐにでもそれを見せるのがベストだと考えます。
この考えが正しければ、ソフトウェアを小さな単位で大きくしていきながら、顧客の真のニーズに合致したアプリケーションに近づけることは理屈的に正しい。
アジャイルでは、顧客が本当にほしいものを作り出すための最も効果の高いやりかたは、顧客とコラボレートすることだと考えます。ソフトウェアを小さな単位で作り、
それをすぐに見てもらうことによって、次はどうする？といったアイデアを練っていく機会を得られます。コラボレーションによって当初想定されていたのとは
違うソフトウェアを生み出すことこそがアジャイルな体験です。ソフトウェアは結果的にもたらされるものであり、あらかじめその姿を正確に予想することは
良くも悪くもできないのです。アジャイルのこうした考え方が正しいならば、もう２つのことも同様に正しいはずです。ひとつは、BUFD（Big Up Front Design）を実践
することにはまったく意味がないということ（なぜならまったく正しくないからです）。そしてもうひとつは、アプリケーションがいつ完成するのかは誰にも予想できない
ということです。

アジャイルに居心地の悪さを感じる人がいるのも当然です。確かに「自分たちがしていることを自分たちは知らない」「自分たちの仕事がいつ終わるのか自分たちには分からない」
といった考え方は理解しがたいものでしょう。BUFD への根強い支持の理由は、ある人たちにとってはそれが他では得られない支配感（a feeling of control）を与えてくれるからです。
支配感は心地いいものでしょうが、アプリケーションを実際に書くという行為の前で、それは儚くも消え去ってしまう運命にあります。

BUFD は、顧客とプログラマとの関係をどうしても敵対的なものに仕向けてしまいます。ソフトウェアが現実に動き出す前に作られたビッグ・デザインは、
そもそも正確ではないし、そのような特定の保証のもとに書かれたアプリケーションは、顧客のニーズにマッチしないものです。
顧客は、ソフトウェアを使ったときにはじめてそのことに気づきます。顧客は変更を求めます。プログラマは変更を固辞します。プログラマには別のスケジュールがあって、
それもすでに遅れ気味なのです。こうしてプロジェクトはだんだんと、関係者が成功させようとするものから失敗を責められまいと凌ぐものへと変質していくのです。

この対立の図式は誰にとってもはっきりしています。プロジェクトが納期に間に合わなかったとき、たとえそれが仕様変更が原因で起こったことだとしても、
プログラマの責任が問われます。一方、プロジェクトは納期に間に合ったけれど現実のニーズを満たしていなかったとき、それは仕様書に問題があったということになり、
今度は顧客が非難されます。BUFD の設計書の書き出しはきまって、アプリケーション開発のロードマップですが、これが段々と反対意見の焦点になっていきます。
彼らは品質の高いソフトウェアを書くことをせずに、その代わり、プロジェクトの最後に発せられることを見越してよく練られたことばの数々を猛烈に供給します。
そうやって、最後にババを引かないよう懸命に予防線を引くのです。

おなじことを何度も繰り返しているにも関わらず、その都度異なる結果を期待することが狂気なら、わたしたちみんなが正気に戻り始めた場所こそが
アジャイル宣言でした。アジャイルが機能するのは、アプリケーションが存在する以前には何の確証も得ることはできない、という認識があるからです。
このアジャイルの認識があるからこそ、ターゲットもタイムラインも分からない状況でソフトウェアを開発するというハンディキャップを乗り越えることができるのです。

アジャイルが「BUFD はするな」といっても、それはまったくデザインするなといっているわけではありません。BUFD でいう「デザイン」とオブジェクト指向デザイン
のそれとでは意味が異なります。BUFD でいうデザインとは、アプリケーションのすべてのフィーチャについて、将来起こりうる内部の挙動を完璧に定義し、ドキュメント化
することです。そんなアーキテクトなら、あらかじめすべてのコードをどのようにアレンジすべきか決めてしまうことだってできるでしょう。オブジェクト指向デザイン
でいう「デザイン」はもっと小さな領域の話です。それは、変更が簡単にできるようなコードはどのように書けば良いかということです。

アジャイルな開発プロセスは「変更を保証」し、変更できるかどうかはアプリケーションのデザイン次第です。よくデザインされたコードを書けないなら、
イテレーションごとにアプリケーションを書き直さなくてはならないでしょう。

アジャイルはこのように、デザインを忌避することはなく、むしろデザインを必要とします。単にデザインを必要とするだけでなく、よいデザインを必要とします。
よいデザインをするにはベストな仕事をしなくてはいけません。そして、デザインが成功するかしないかは、コードのシンプルさ、柔軟性、順応性にかかっているのです。

#### デザインの評価

プログラマはかつて、書いたコードの行数によって評価されることがときどきありました（source lines of code または SLOC で検索してみてください）。
このようなメトリクス（評価基準値）を採用した結果は明白です。プログラミングを画一的に訓練を受けた労働者による規格品組み立てラインと見なしている上司は、
個々のプログラマの生産性など、定量的な数値で評価できると簡単に信じてしまいます。プログラマの良し悪しを比較して、ソフトウェア
を評価しようと躍起になっている管理職たちからすれば、SLOC は、明らかに問題があるのに、何もないよりは遥かに使えるものと映るのです。
彼らにとって、少なくとも「何か」を評価できる再利用可能なものさしにはなるのです。

このメトリクスはプログラマが開発したものではありません。SLOC は個人の努力とアプリケーションの複雑さについて、ある尺度を与えてはくれますが、
全体の品質については沈黙しています。有能なプログラマを罰する一方で、冗長を奨励しベースアプリケーションを損傷してしまうようなエキスパートたちのコーディングゲーム
を誘発します。あなたの隣に座っている新人プログラマが数行で実装できるはずのフィーチャを、大量のコードで実装しているがゆえに生産性が高いと評価されるとしたら、
あなたはどう思うでしょうか？このメトリクスは品質を毀損しても評価されるようなおかしな基準をもたらしてしまいます。

モダンな世界では、SLOC はもはや歴史上の興味になってしまい、すでにより新しいメトリクスに取って代わられています。コードが OOD の原則にどの程度則っているか
評価する Ruby gems が数多く存在します（"ruby metrics" で google サーチすれば最新の動向がわかります）。そうしたメトリクス・ソフトウェアはソースコードをスキャンして、
品質を見積もります。コードに対してメトリクス・スイートを実行すると、賞賛したり、けなしたり、アラートをあげてきたりします。一見、よくデザインされているように見える
アプリケーションであっても OOD の原則に違反していたりするものです。

メトリクスが悪いのなら、それは疑いなく悪いデザインのサインです。スコアの低いコードは将来変更がむつかしくなるかもしれません。
でも残念ながら、スコアが高いからといって良いデザインの証にはなりません。つまり、スコアの高さによっては次に発生する変更が簡単で安くあがるかは保証ないからです。
将来をあまりに見越し過ぎたようなデザインはどれほど美しくても問題です。そうしたデザインはメトリクスが高くても、悪い未来を見越している限り、実際にその時がきたとき
変更は高くつくでしょう。メトリクスは間違ったことを正しいやり方でするようなデザインを見極めることはできません。

> under development

#### まとめ

それなりに長期間動いているアプリケーション、つまり成功しているアプリケーションが遭遇する最大の問題は変更への対処です。
変更に対して手際よく対処できるようコードをアレンジすることはデザインの仕事です。デザインでいちばんわかりやすい要素は基本原則とパターンですが、
基本原則をいくら正しく適用しても、パターンをいくら適切に使っても変更しやすいアプリケーションの開発を保証してくれたりはしません。

メトリクスは、アプリケーションがどの程度オブジェクト指向デザインの基本原則をフォローしているのか教えてくれます。
メトリクスの悪いアプリケーションは将来何らかの問題に出くわすでしょう。しかし、メトリクスが良いからといって楽観はできません。
問題を起こすようなデザインのメトリクスが良い場合もあるでしょうし、メトリクスが良くても変更のコストは高いままかもしれません。

良いデザインの秘訣は、デザインの理論をきちんと習得すること、そして習得した理論を適切に、つまり正しいタイミングで正しい量を適用することです。
デザインの良し悪しは理論を実践に翻訳するみなさんの力量にかかっています。

理論と実践の違いは何でしょう？

理論には何もありません。もし理論が実践ならば、オブジェクト指向デザインのルールを習得し、ひたすらルールを
適用していけば、その日からパーフェクトなコードを書くことができるでしょう。そこでみなさんの仕事は完了です。

理論がいくらそれを正しいと主張したところで、その主張をよりよく知っているのは実践のほうです。実践は理論とは異なり自らの手を汚します。
煉瓦を積み上げ、橋を架け、コードを書くことが実践です。実践は、変化と混乱と不確実に満ちた現実の世界に生きています。いくつもの選択肢を秤にかけ、
苦々しくありながらも、時に「より邪悪でない」ほうを選択しなければならない状況に遭遇します。身をかわし、隠れ、借りた金で返済したりするのが実践です。
いまある資源でベストを尽くし身過ぎ世過ぎするのが実践なのです。

理論は有益であり必要というのが本章の主張でした。ですがもう理論は十分。いまから実践に移りましょう。

